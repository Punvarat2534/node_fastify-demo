import { AsyncLocalStorage } from "node:async_hooks";
import { PLazy } from "./PLazy.js";
declare class NodeContext {
    name: string;
    hash: string;
    arguments: any[];
    children: NodeContext[];
    constructor(name: string, fn: string, args: any[]);
}
export declare const wrapContext: AsyncLocalStorage<(...args: any[]) => any>;
export declare const getTree: () => {
    children: NodeContext[];
};
export declare function fnWrapper<T extends (...args: any) => any>(name: string, fn: T): T;
export declare class FunctionExecutor<I extends ((...args: any[]) => any) | undefined = undefined, // init
H extends Record<string, any> | ((self: FunctionExecutor<I, H, R, W, E, C, A>) => Record<string, any>) | undefined = undefined, // helpers
R extends ((...args: any[]) => Promise<any> | any) | undefined = undefined, // return
W extends boolean = true, // return wrapped helpers like PLazy<H> & H or not
E extends ((...args: any[]) => Promise<any> | any) | undefined = undefined, // executor
C extends ((...args: any[]) => Promise<any> | any) | undefined = undefined, // callback
A extends ((self: {
    getChildArg: <T>(name: string) => T | undefined;
}) => Promise<any> | any) | undefined = undefined> {
    name: string;
    private _init?;
    private _helpers?;
    private _return?;
    private _context;
    private _copyHelpersToPromise;
    private _executor?;
    private _parentWrapper;
    private _callback?;
    private _arguments?;
    private _done;
    private parentArgs;
    private childArgs;
    private initiated;
    constructor(name: string);
    setParentArgs(...args: any[]): this;
    getChildArgs(): any[];
    getChildArg(name: string): any;
    doNotCopyHelpersToPromise(): FunctionExecutor<I, H, R, false, E, C, A>;
    init<IE extends (...args: any[]) => any>(init: (self: FunctionExecutor<I, H, R, W, E, C, A>) => Promise<void> | void): FunctionExecutor<IE, H, R, W, E, C, A>;
    done(cb: any): this;
    arguments<AE extends (self: {
        getChildArg: <T>(name: string) => T | undefined;
    }) => Promise<any> | any>(args: AE): FunctionExecutor<I, H, R, W, E, C, AE>;
    getArguments(): A extends (self: {
        getChildArg: <T>(name: string) => T | undefined;
    }) => any | Promise<any> ? Awaited<ReturnType<A>> : undefined;
    helpers<HE extends Record<string, any>>(helpers: HE | ((self: FunctionExecutor<I, H, R, W, E, C, A>) => HE)): FunctionExecutor<I, HE, R, W, E, C, A>;
    callback<CE extends (self: FunctionExecutor<I, H, R, W, E, C, A>) => Promise<any> | any>(callback: CE): FunctionExecutor<I, H, R, W, E, CE, A>;
    wrappedHelpers(): H extends (...args: any[]) => any ? ReturnType<H> : H;
    wrapHelpers<HR extends Record<string, any>>(helpers: HR): HR;
    context(): (cb?: any, ...childArgs: any[]) => any;
    return<RE extends (self: FunctionExecutor<I, H, R, W, E, C, A>) => Promise<any> | any>(_return: RE): FunctionExecutor<I, H, RE, W, E, C, A>;
    executor<EE extends (next: (...args: any[]) => Promise<void> | void, self: FunctionExecutor<I, H, R, W, E, C, A>) => Promise<any> | any>(executor: EE): FunctionExecutor<I, H, R, W, EE, C, A>;
    run(): R extends (...args: any[]) => Promise<any> | any ? W extends true ? PLazy<Awaited<ReturnType<R>>> & Awaited<ReturnType<R>> : PLazy<Awaited<ReturnType<R>>> : void;
}
export {};
